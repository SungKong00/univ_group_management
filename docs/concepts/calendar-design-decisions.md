# 캘린더 시스템 설계 결정사항 (Calendar Design Decisions)

> **상위 문서**: [캘린더 시스템](calendar-system.md)
> **관련 문서**: [권한 시스템](permission-system.md) | [장소 관리](calendar-place-management.md)

본 문서는 캘린더 시스템 설계 과정에서 내린 핵심 결정사항을 기록합니다. 각 결정사항은 고유 ID, 결정 내용, 이유, 영향을 명시하여 향후 유지보수 및 기능 확장 시 참고할 수 있도록 합니다.

---

## DD-CAL-001: 권한 통합 방식

**결정**: 캘린더 권한을 기존 RBAC 시스템에 통합 (Option A 채택)

**배경**: 캘린더 시스템에 필요한 권한을 기존 그룹 권한 체계에 통합할지, 독립적인 권한 시스템으로 운영할지 결정 필요

**고려한 대안**:
- Option A: GroupRole에 캘린더 권한 추가 (CALENDAR_VIEW, CALENDAR_MANAGE, PLACE_MANAGE, PLACE_RESERVE)
- Option B: 독립적인 CalendarPermission 엔티티 및 권한 확인 로직

**선택 이유**:
- 일관된 권한 확인 로직 유지 (PermissionService 재사용)
- 개발 복잡도 감소 (권한 확인 로직 이원화 방지)
- 사용자 학습 곡선 최소화 (단일 권한 설정 UI)
- 채널 권한과 동일한 Permission-Centric 매트릭스 적용 가능

**영향**:
- GroupRole에 4개 캘린더 권한 추가
- PermissionService 확장 필요
- 권한 매트릭스 UI에 캘린더 탭 추가

**기각된 대안의 문제점**:
- Option B: 권한 확인 로직 이원화로 복잡도 증가, 캐싱 전략 분리 필요

---

## DD-CAL-002: 반복 일정 저장 방식

**결정**: 명시적 인스턴스 저장 방식 (Option B)

**배경**: 반복 일정(예: 매주 월요일 회의)을 저장할 때 패턴만 저장할지, 각 인스턴스를 명시적으로 저장할지 결정 필요

**고려한 대안**:
- Option A: 반복 패턴만 저장, 조회 시 동적 생성
- Option B: 반복 범위만큼 개별 인스턴스 생성하여 저장

**선택 이유**:
- 개별 일정 수정/삭제 로직 단순화 (단일 레코드 업데이트)
- 예외 처리 용이 (특정 날짜만 시간/장소 변경 가능)
- 미래 일정 무한 확장 방지 (저장 시점에 범위 확정)
- 조회 성능 향상 (동적 계산 불필요)

**영향**:
- 일정 생성 UI에서 반복 범위 지정 필수 (예: "3개월 후까지")
- 반복 패턴 수정 시 미래 인스턴스 일괄 업데이트 로직 필요
- 저장 공간 증가 (트레이드오프)

**기각된 대안의 문제점**:
- Option A: 예외 처리 복잡 (특정 날짜 수정 시 패턴 + 예외 조합), 무한 반복 처리 어려움

---

## DD-CAL-003: 반복 일정 예외 처리

**결정**: EventException 엔티티로 분리 관리

**배경**: 반복 일정 중 특정 날짜만 시간/장소가 다른 경우(예: 이번 주만 회의실 변경) 처리 방법 결정

**고려한 대안**:
- Option A: 원본 일정에 `isException` 플래그 추가
- Option B: EventException 별도 엔티티로 관리 (parentEventId, exceptionDate, 수정 필드)

**선택 이유**:
- 원본 반복 패턴 보존 (전체 반복 일정 수정 시 예외 재적용 가능)
- 예외 조회 성능 최적화 (exceptionDate 인덱스 활용)
- 추후 "이 일정만 수정" vs "이후 모든 일정 수정" UI 확장 가능
- 데이터 무결성 (예외가 부모 일정에 종속)

**영향**:
- 일정 조회 시 EventException LEFT JOIN 필요
- 일정 수정 UI에서 "이 일정만" / "반복 전체" 선택 기능 구현
- 부모 일정 삭제 시 예외도 계단식 삭제

**기각된 대안의 문제점**:
- Option A: 원본 패턴 손실, 반복 전체 수정 시 예외 재계산 불가, 조회 성능 저하

---

## DD-CAL-004: 참여자 관리 방식

**결정**: EventParticipant 독립 엔티티 (Option A)

**배경**: 일정 참여자 정보를 GroupEvent 내 JSON 배열로 저장할지, 별도 테이블로 관리할지 결정

**고려한 대안**:
- Option A: EventParticipant 엔티티 (eventId, userId, status, declineReason)
- Option B: GroupEvent의 `participantIds: List<Long>` JSON 필드

**선택 이유**:
- 참여 상태(참여/불참/보류) 추적 가능
- 불참 사유 저장 기능 (UI에서 선택/직접 입력)
- 추후 알림 발송 이력 관리 용이 (sentAt 컬럼 추가 가능)
- 참여자별 필터링 쿼리 성능 (인덱스 활용)

**영향**:
- 일정 생성 시 대상자 자동 참여자 생성 로직 필요
- 참여 상태 변경 API 별도 구현
- 일정 조회 시 EventParticipant JOIN으로 참여자 정보 포함

**기각된 대안의 문제점**:
- Option B: 참여 상태 추적 불가, 쿼리 복잡도 증가 (JSON 배열 검색), 확장성 제한

---

## DD-CAL-005: 시간표 데이터 정규화

**결정**: Course와 CourseTimetable 분리

**배경**: 대학 강의 정보를 단일 테이블로 관리할지, 과목과 시간표를 분리할지 결정

**고려한 대안**:
- Option A: Course (과목 정보) + CourseTimetable (분반별 시간표)
- Option B: 통합 Course 테이블에 모든 정보 저장

**선택 이유**:
- 동일 과목의 여러 분반 지원 (예: "데이터베이스 01분반", "데이터베이스 02분반")
- 학기별 과목 재사용 가능 (과목명, 학점은 동일, 시간만 변경)
- 관리자의 과목 정보 일괄 수정 지원 (모든 분반에 영향)
- 데이터 중복 최소화

**영향**:
- 사용자 시간표 추가 플로우: Course 검색 → CourseTimetable 선택
- Course 삭제 시 CourseTimetable 계단식 삭제
- 시간표 조회 시 Course JOIN 필요

**기각된 대안의 문제점**:
- Option B: 과목 정보 중복 저장, 일괄 수정 불가, 확장성 제한

---

## DD-CAL-006: 장소 예약 통합 방식

**결정**: PlaceReservation을 GroupEvent의 부속 정보로 관리

**배경**: 장소 예약을 독립적인 자원으로 관리할지, 일정의 부속 정보로 관리할지 결정

**고려한 대안**:
- Option A: PlaceReservation이 GroupEvent를 참조 (FK: eventId)
- Option B: PlaceReservation 독립 엔티티 (일정 없는 예약 가능)

**선택 이유**:
- 비즈니스 규칙: 일정과 장소가 1:1 관계 (일정 없는 예약 불필요)
- 일정 삭제 시 예약 자동 삭제 (계단식 삭제로 무결성 보장)
- 예약 현황 조회 = 일정 조회로 단순화 (별도 API 불필요)
- 일정 생성 UI에서 장소 선택으로 통합 경험 제공

**영향**:
- 일정 없는 장소 예약 불가 (UI에서 "일정 없이 예약" 버튼 미제공)
- 일정 조회 시 PlaceReservation LEFT JOIN
- 장소 캘린더 = 해당 장소를 포함한 일정 필터링

**기각된 대안의 문제점**:
- Option B: 일정-예약 동기화 복잡, 일정 삭제 시 예약 고아 레코드 발생 가능

---

## DD-CAL-007: 최적 시간 추천 알고리즘

**결정**: 가능 인원 최대화 알고리즘 (Option A)

**배경**: "대상자 지정" 일정 생성 시 최적 시간을 추천하는 알고리즘 선택

**고려한 대안**:
- Option A: 참여 가능한 인원이 가장 많은 시간대 추천
- Option B: 가중치 기반 (직책별 가중치 부여)

**선택 이유**:
- 비즈니스 목적 명확성 (참석률 최대화)
- 사용자 직관적 이해 ("30명 중 25명 가능")
- 구현 단순성 (집계 쿼리 기반)
- 초기 MVP에 적합

**영향**:
- 소수 핵심 인원 무시 가능 (예: 그룹장 불참 시간도 추천될 수 있음)
- 시간대별 가능/불가능 인원 수 시각화 UI 필요
- 추후 "필수 참석자" 기능으로 보완 고려

**기각된 대안의 문제점**:
- Option B: 가중치 설정의 주관성, 사용자 설정 복잡도 증가

---

## DD-CAL-008: 동시성 제어 전략

**결정**: 낙관적 락 + 트랜잭션 격리 레벨 REPEATABLE_READ

**배경**: 장소 예약 및 참여 신청 시 동시 요청으로 인한 충돌 방지 전략 필요

**고려한 대안**:
- Option A: 낙관적 락 (@Version) + 재시도 로직
- Option B: 비관적 락 (SELECT FOR UPDATE)
- Option C: 분산 락 (Redis)

**선택 이유**:
- 대부분의 경우 충돌 가능성 낮음 (낙관적 락 적합)
- 장소 예약: 생성 전 중복 검증 쿼리로 충돌 최소화
- 참여 신청: 제한 인원 없는 경우 충돌 문제 없음
- 단순성: @Version 어노테이션만으로 구현 가능
- 성능: 락 대기 시간 없음

**영향**:
- PlaceReservation 엔티티에 `@Version` 컬럼 추가
- 예약 생성 API에서 중복 검증 쿼리 먼저 실행
- 충돌 발생 시 사용자에게 "이미 예약된 시간입니다" 응답
- 참여 신청 제한 인원 기능 추가 시 비관적 락 고려

**기각된 대안의 문제점**:
- Option B: 락 경합으로 성능 저하, 데드락 가능성
- Option C: 초기 MVP에 과도한 복잡도, Redis 인프라 추가 필요

---

## 다음 단계

### 백엔드 구현 필요
- 설계 결정사항 기반 엔티티 클래스 작성
- 권한 확인 로직에 캘린더 권한 통합
- 반복 일정 생성/수정/삭제 로직 구현
- 동시성 제어 테스트 (낙관적 락 충돌 시나리오)

### 프론트엔드 구현 필요
- 반복 범위 설정 UI
- "이 일정만" / "반복 전체" 선택 UI
- 최적 시간 추천 결과 시각화
- 예약 충돌 에러 핸들링

### 관련 문서
- [캘린더 시스템](calendar-system.md) - 전체 개념 및 기능 명세
- [권한 시스템](permission-system.md) - 캘린더 권한 매트릭스
- [장소 관리](calendar-place-management.md) - 장소 예약 권한 상세
- [데이터베이스 참조](../implementation/database-reference.md) - 캘린더 스키마 상세
