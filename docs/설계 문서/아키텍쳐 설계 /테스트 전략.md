# 테스트 전략

### 1. 핵심 원칙 및 목표

- **원칙: 테스트 피라미드 (Testing Pyramid)**
    - 빠르고 저렴한 **단위 테스트**와 **통합 테스트**에 집중하고, 비용이 많이 드는 E2E 테스트는 MVP 범위에서 제외하여 효율성을 극대화합니다.
- **최우선 목표: 통합 테스트 (Integration Test)**
    - API 엔드포인트부터 데이터베이스까지, **핵심 기능의 전체 흐름을 검증**하는 통합 테스트 작성을 최우선으로 합니다. 이를 통해 API가 의도대로 동작함을 보장합니다.
- **차순위 목표: 단위 테스트 (Unit Test)**
    - 복잡한 비즈니스 로직(예: 권한 계산, 특정 조건 분기)이 포함된 `Service` 계층에 한해, 로직의 정확성을 검증하기 위한 단위 테스트를 작성합니다.

---

### 2. 테스트 환경

- **데이터베이스:** 실제 운영 DB와 별개로, 테스트 실행 시에만 메모리에서 동작하는 **H2 인메모리 데이터베이스**를 사용합니다. 이를 통해 빠르고 독립적인 테스트 환경을 보장합니다.

---

### 3. 테스트 코드 구조화 전략 (Acceptance Test 스타일)

테스트 코드의 중복을 제거하고 가독성을 높여, 개발 리소스를 절감하기 위해 아래와 같은 헬퍼(Helper) 구조를 도입합니다.

- **`AcceptanceTest` 헬퍼 클래스**
    - 모든 통합 테스트에서 공통으로 사용되는 기능(API 요청, JSON 변환 등)을 모아둔 클래스입니다.
    - 복잡한 `MockMvc` 코드를 캡슐화하여, 테스트 코드에서는 `acceptanceTest.회원가입()` 과 같이 비즈니스 용어로 API를 호출할 수 있게 합니다.
- **`DatabaseCleanup` 컴포넌트**
    - 각 테스트 메서드 실행 **후(`@AfterEach`)** 모든 DB 테이블의 데이터를 삭제하는 역할을 합니다.
    - 이를 통해 다음 테스트가 완벽하게 깨끗한 상태에서 시작되도록 보장하여 테스트 간의 격리성을 높입니다.
- **`IntegrationTest` 기반 클래스**
    - 모든 통합 테스트 클래스가 상속받을 추상 클래스입니다.
    - `@SpringBootTest` 어노테이션과 `DatabaseCleanup` 로직이 미리 포함되어 있어, 반복적인 설정을 줄여줍니다.

---

### 4. 주요 구현 규칙

- **테스트 데이터 준비:**
    - 각 테스트에 필요한 데이터는 **`@BeforeEach`** 어노테이션이 붙은 메서드 내에서 생성합니다. 이를 통해 모든 테스트는 예측 가능한 초기 상태에서 시작됩니다.
- **인증 처리:**
    - 로그인이 필요한 API를 테스트할 때는, Spring Security Test의 **`@WithMockUser` 어노테이션**을 사용하여 간편하게 인증 상태를 시뮬레이션합니다.
- **파일 위치 및 명명 규칙:**
    - **위치:** `src/test/kotlin`
    - **패키지:** `src/main/kotlin`의 패키지 구조를 그대로 따릅니다.
    - **이름:** 테스트할 클래스 이름 뒤에 `Test`를 붙입니다. (예: `UserService` → `UserServiceTest`)

---

### 5. 전체 시나리오 예시: '그룹 생성 인수 테스트'

아래는 위 모든 전략을 적용한 최종 테스트 코드의 모습입니다.

Kotlin

`// DatabaseCleanup 기능이 포함된 기반 클래스를 상속받는다.
class GroupAcceptanceTest(
    // 공통 API 요청 기능이 담긴 헬퍼 클래스를 주입받는다.
    @Autowired private val acceptanceTest: AcceptanceTest
) : IntegrationTest() {

    private lateinit var testUserToken: String

    @BeforeEach
    fun setup() {
        // 각 테스트 전에 필요한 사용자 데이터를 만들고, 로그인하여 토큰을 받아둔다.
        val signupRequest = SignupRequest(email = "test@user.com", ...)
        testUserToken = acceptanceTest.signupAndGetToken(signupRequest)
    }

    @Test
    fun `로그인한 사용자는 성공적으로 그룹을 생성한다`() {
        // given
        val createGroupRequest = CreateGroupRequest(name = "새로운 스터디 그룹", ...)

        // when
        // 헬퍼 클래스를 사용하여 시나리오처럼 읽기 쉽게 API를 호출한다.
        val response = acceptanceTest.createGroup(createGroupRequest, testUserToken)

        // then
        // 응답 코드가 '201 Created'인지 검증한다.
        response.andExpect(status().isCreated)
    }
}`