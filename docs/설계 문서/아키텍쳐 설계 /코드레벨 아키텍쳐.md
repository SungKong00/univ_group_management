# 코드레벨 아키텍쳐

## ## 코드 레벨 아키텍처 최종 확정본 (v1.0)

이 문서는 Spring Boot 프로젝트의 코드를 작성하는 모든 규칙과 책임을 정의합니다. 이 아키텍처의 목표는 코드의 **일관성, 가독성, 테스트 용이성**을 확보하여 장기적으로 유지보수하기 쉬운 애플리케이션을 만드는 것입니다.

### 1. 계층형 아키텍처 (Layered Architecture)

프로젝트는 **Controller, Service, Repository**의 3가지 핵심 계층으로 역할을 명확히 분리합니다. 데이터의 흐름은 항상 단방향(`Controller` → `Service` → `Repository`)을 유지합니다.

- **`Controller` (교통 경찰관 👮):**
    - HTTP 요청을 받고 응답하는 역할만 수행합니다.
    - 요청 데이터(DTO)의 **형식(Syntax)을 1차적으로 검증**합니다.
    - `Service` 계층을 호출하여 비즈니스 로직 처리를 위임합니다.
- **`Service` (브레인 🧠):**
    - 애플리케이션의 **모든 비즈니스 로직**을 처리합니다.
    - **데이터베이스 트랜잭션**을 관리합니다.
    - **DTO와 Entity 간의 데이터 변환**을 책임집니다.
    - 비즈니스 규칙(Semantic)에 대한 **2차 유효성 검사**를 수행합니다.
- **`Repository` (창고 관리인 📦):**
    - 데이터베이스와 직접 통신하여 **데이터 영속성(Persistence)**만을 담당합니다. (CRUD)
- **`DTO` (운반 상자 🗳️):**
    - 각 계층 간, 특히 외부(Controller)와 데이터를 주고받을 때 사용하는 데이터 전용 객체입니다.

---

### 2. 핵심 개발 규칙 (Core Development Rules)

### **2.1. 유효성 검사 (Validation)**

유효성 검사는 2단계에 걸쳐 수행됩니다.

1. **Controller (형식 검사):** DTO에 `@NotBlank`, `@Size`, `@Email` 등의 어노테이션을 사용하여 데이터의 형식을 검증합니다. Controller 메서드는 `@Valid` 어노테이션으로 이를 활성화합니다.Kotlin
    
    `// CreateGroupRequest.kt
    data class CreateGroupRequest(
        @field:NotBlank @field:Size(min = 2, max = 20)
        val name: String,
        // ...
    )
    
    // GroupController.kt
    @PostMapping
    fun createGroup(@Valid @RequestBody request: CreateGroupRequest) { ... }`
    
2. **Service (비즈니스 규칙 검사):** DB 조회가 필요한 '이미 존재하는 이름인지'와 같은 비즈니스 규칙은 `Service` 계층에서 직접 로직으로 검증하고, 실패 시 커스텀 예외(`Custom Exception`)를 발생시킵니다.

### **2.2. DTO와 Entity 변환 (DTO & Entity Conversion)**

데이터 변환의 책임은 **오직 `Service` 계층에만 있습니다.**

- **Controller → Service:** Controller는 DTO를 받아 Service에 전달합니다. Service는 이 DTO를 Entity로 변환하여 로직을 처리합니다.
- **Service → Controller:** Service는 로직 처리 후 얻은 Entity를 Response DTO로 변환하여 Controller에 반환합니다.
- **엄격한 규칙:** `Controller`는 절대로 `Entity`를 알아서는 안 되며, `Repository`는 절대로 `DTO`를 알아서는 안 됩니다.

### **2.3. 트랜잭션 관리 (Transaction Management)**

데이터의 일관성이 필요한 모든 비즈니스 로직은 트랜잭션 내에서 처리되어야 합니다.

- **규칙:** **`@Transactional`** 어노테이션은 **`Service` 클래스의 `public` 메서드**에만 사용하는 것을 원칙으로 합니다.
- **이유:** 비즈니스 로직의 단위와 트랜잭션의 단위를 일치시켜, 여러 DB 작업이 하나의 묶음으로 처리되도록 보장합니다.

---

### 3. 전체 동작 흐름 예시: '그룹 생성'

1. **[요청]** 사용자가 그룹 이름, 설명을 담은 JSON을 `POST /api/groups`로 요청합니다.
2. **[Controller]** `GroupController`가 요청을 받습니다.
    - `@Valid` 어노테이션을 통해 `CreateGroupRequest` DTO의 **형식(이름 길이 등)을 1차 검증**합니다.
    - `groupService.createGroup(request)`를 호출합니다.
3. **[Service]** `GroupService`의 `@Transactional`이 붙은 `createGroup` 메서드가 실행됩니다.
    - "이미 존재하는 그룹 이름인지" **비즈니스 규칙을 2차 검증**하고, 중복 시 예외를 발생시킵니다.
    - `CreateGroupRequest` **DTO를 `Group` Entity로 변환**합니다.
    - `groupRepository.save(group)`를 호출합니다.
    - 현재 로그인한 사용자를 '그룹장'으로 지정하는 `Member` 엔티티를 생성하고, `memberRepository.save(member)`를 호출합니다.
    - 생성된 `Group` **Entity를 `GroupResponse` DTO로 변환**하여 Controller에 반환합니다.
4. **[Repository]** `GroupRepository`와 `MemberRepository`가 DB에 데이터를 저장합니다.
5. **[응답]** `Controller`는 `Service`로부터 받은 DTO를 JSON으로 변환하여 `201 Created` 상태 코드와 함께 사용자에게 응답합니다.